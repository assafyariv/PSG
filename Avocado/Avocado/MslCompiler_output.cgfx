/******************************************************************************
 * The following code was generated by the mental mill(R)                     *
 * Fx_code_generator build 98330.4787.4752 10 Dec 2009 nt-x86                 *  
 *                                                                            *
 * Portions Copyright (c) 1986-2009 mental images GmbH, Berlin, Germany.          *
 ******************************************************************************/

// shader type surface

//
// The state structure is used internally within the fragment shader to
// commonly used values.
//
struct State
{
	float3 position;
	float3 origin;
	float3 normal;
	float3 direction;
	float ray_length;
};

struct Trace_options
{
	int ray_type;
	bool enable_environment;
};

//
// Values for the light_type parameter of light shaders
//
#define LIGHT_POINT    0
#define LIGHT_SPOT     1
#define LIGHT_INFINITE 2
#define LIGHT_PLANAR   3

//
// The light iterator structure holds the return values resulting from
// evaluating a light.
//
#ifndef __LIGHT_ITERATOR_STRUCT
#define __LIGHT_ITERATOR_STRUCT
struct Light_iterator {
    float3 msl_point;
    float4 msl_contribution;
    float4 msl_raw_contribution;
    float  msl_dot_nl;
    float3 msl_direction;
    float  msl_distance;
    float4 msl_shadow;
    int    msl_count;
};
#endif // __LIGHT_ITERATOR_STRUCT

struct Ray {
    float3 msl_origin;
    float3 msl_direction;
};

bool Ray_equal(Ray a,Ray b) {
    return all(a.msl_origin == b.msl_origin)
        && all(a.msl_direction == b.msl_direction);
}


//
// Scale parameter for ddx and ddy calls
//
uniform float __differential_scale = 1.0;

void __make_basis(const float3 n, const float3 u, const float3 v,
        out float3 t, out float3 b)
{
    b = normalize(cross(u,n));
    t = cross(n,b);
    if (dot(b,v) < 0.0)  b = -b;
}

float3 __perspective_divide(float4 pt)
{
    return pt.xyz/pt.w;
}

// 
// State dependant variable recalculation. 
// 
void __update_state_origin_or_position(inout State state) 
{ 
    state.direction = state.position - state.origin; 
    state.ray_length = length(state.direction); 
    state.direction = normalize(state.direction); 
} 

uniform int __object_label = 0; 
// 
// Encoding of Renderer::label internal state (int) as float4. 
// 
float4 _label_as_color() 
{ 
    int n = __object_label; 
    float4 c; 
    c.a = float(n / 16777216); 
    c.b = float((n % 16777216) / 65536); 
    c.g = float((n % 65536) / 256); 
    c.r = float(n % 256); 
    c /= 255.0;
    return c; 
} 

uniform float4 __clip_plane = float4(1, 1, 0, 0);




//
// The following are parameters representing non-varying state variables 
// referenced by the shader. These should be set by the application at runtime.
// Note that vector parameters should be provided in camera space.
//
float4x4 __object_to_ndc : WorldViewProjection
<
	string UIWidget = "none";
>;
bool __orthographic = false;
float4x4 __world_to_object : WorldInverse
<
	string UIWidget = "none";
>;
float4x4 __object_to_world : World
<
	string UIWidget = "none";
>;
float4x4 __camera_to_world : ViewInverse
<
	string UIWidget = "none";
>;
//                                                   
// The following are parameters representing non-varying non-state variables      
// referenced by the shader. These should be set by the application at runtime.             
//                                                   
float4x4 __internal_to_light;
float4x4 __light_to_internal;



//
// The App2vert structure defines the vertex attributes used by the vertex
// shader. The application should supply a vertex stream containing these 
// elements.
//
struct App2vert
{
	float3 position : POSITION;
	float3 normal : NORMAL;
};

//
// The Vert2frag structure defines values used by the fragment shader and
// supplied by the vertex shader.
//
struct Vert2frag
{
	float4 hpos : POSITION;
	float3 position : TEXCOORD0;
	float3 normal : TEXCOORD1;
	float clipDist : CLP0;
};

//
// This function is the main method of the vertex shader.
//
Vert2frag vertex_main(
	App2vert vs_in)
{
	Vert2frag vs_out;
	float4 position = float4(vs_in.position, 1);
	vs_out.hpos = mul(__object_to_ndc, position);
	vs_out.position = mul(__object_to_world, position).xyz;
	vs_out.normal = mul(vs_in.normal, (float3x3)__world_to_object);
	vs_out.clipDist = dot(float4(vs_out.position, 1), mul(__clip_plane, __camera_to_world));
	return vs_out;
}

//
// Declaration of final output type. For MRT, this is a struct.
//
typedef float4 FS_OUT;

//
// The following functions are generated from the MetaSL implementation of
// the shaders that are part of the compiled shader graph.
//

//
// The following method is the root function of the shader graph
//
float4 my_red_eval(State state, out FS_OUT eval_out)
{
	// primary_out: 
	float4 msl_result;
	msl_result = (float4((float(1)), (float(0)), (float(0)), (float(1))));
	eval_out = float4(msl_result);
	return float4(msl_result);
}

//
// This function is the main method of the fragment shader. It initializes the
// values in the state structure that are used by nodes in the shader graph
// and produces the final result of the shader.
//
FS_OUT fragment_main(
	Vert2frag fs_in) : COLOR
{
	State state;
	state.position = fs_in.position;
	state.normal = normalize(fs_in.normal);
	state.origin = float3(__camera_to_world[0][3], __camera_to_world[1][3], __camera_to_world[2][3]);
	float3 eye_to_pos = state.position - state.origin;
	state.ray_length = __orthographic ? abs(eye_to_pos.z) : length(eye_to_pos);
	state.direction = __orthographic ? float3(0, 0, -1) : eye_to_pos/state.ray_length;

	FS_OUT eval_out;  // multiple shader outputs
	float4 primary_out;  // primary shader output
	primary_out = my_red_eval(state, eval_out);
	FS_OUT fs_out;
	fs_out = primary_out;
	return fs_out;
}

//
// The following define the default technique and pass of the effect.
//
technique T0
{
	pass P0
	{
		VertexShader = compile latest vertex_main();
		PixelShader  = compile latest fragment_main();
	}
}

