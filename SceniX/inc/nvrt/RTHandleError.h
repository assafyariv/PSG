// Copyright NVIDIA Corporation 2002-2005
// TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW, THIS SOFTWARE IS PROVIDED
// *AS IS* AND NVIDIA AND ITS SUPPLIERS DISCLAIM ALL WARRANTIES, EITHER EXPRESS
// OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY
// AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL NVIDIA OR ITS SUPPLIERS
// BE LIABLE FOR ANY SPECIAL, INCIDENTAL, INDIRECT, OR CONSEQUENTIAL DAMAGES
// WHATSOEVER (INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS,
// BUSINESS INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR ANY OTHER PECUNIARY LOSS)
// ARISING OUT OF THE USE OF OR INABILITY TO USE THIS SOFTWARE, EVEN IF NVIDIA HAS
// BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES 

#pragma once

#include <nvrt/nvsgrtapi.h>
#include <nvrt/NVIRTFunctions.h>
#include <nvrt/NVIRTGLFunctions.h>
#include <nvrt/NVIRTUFunctions.h>
#include <nvrt/RTInit.h>
#include <nvutil/Assert.h>
#include <nvutil/IOLayer.h>
#include <sstream>

struct RTHandleError
{
  typedef int (*UserErrorCallback)( RTresult code, const char * message );

  static void setContext( RTcontext ctxt ) { context = ctxt; }
  static void handleError(RTresult code, const char * file, int line)
  {
    std::stringstream ss;
    const char * message;
    RTContextGetErrorString(context, code, &message);

    ss << "OptiX Failure: " << file << " (" << line << "): " << code << std::endl;
    ss << "               " << message << std::endl;

    if( ucallback )
    {
      if( (*ucallback)( code, ss.str().c_str() ) == 0 )
      {
        return;
      }
    }

    nvutil::IO::errorMessage( "RayTracing Error", ss.str(), false );

#ifdef _WIN32
    DebugBreak();
#endif
  }

  //! Set a user-defined failure callback.
  /** This function registers a user-defined routine to call in the event of an optix ray tracing 
   * error.
   * \param cb A callback routine to call that is of type UserErrorCallback.
   * \return Returns the previous callback, if one was registered.
   * \note The user-defined callback should have a prototype:
   *
   *    int callback( RTresult code, const char * message );
   *    
   *    code will be a result code as defined in inc/nvrt/nvirt/optix.h
   *    message will be a text message generated by optix for this error
   *
   *    and should return 0 to have nvsg simply return from the assertion failure
   *    and not process it any further, nonzero to have SceniX continue with assertion processing 
   *    for the host OS.
    */
  NVRT_API static UserErrorCallback SetUserErrorCallback( UserErrorCallback cb )
  {
    UserErrorCallback oldcb = ucallback;
    ucallback = cb;
    return oldcb;
  }

  NVRT_API static UserErrorCallback ucallback;
  NVRT_API static RTcontext context;
};

#define RT_VALIDATE( func )                     \
  do {                                          \
    RTresult code = func;                       \
    if( code != RT_SUCCESS )                    \
      RTHandleError::handleError( code, __FILE__, __LINE__ );  \
  } while(0)

